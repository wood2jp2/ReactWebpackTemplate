1. Create an index.html file within a 'public' folder.
2. Ensure that 'babel-cli@6.24.1', and 'live-server' are installed globally using command 'npm install -g      [package]'
3. Hook up React using one of two ways:
    + Add the following script tags to the HTML file:
            <script src="https://unpkg.com/react@16.0.0/umd/react.development.js"></script>
            <script src="https://unpkg.com/react-dom@16.0.0/umd/react-dom.development.js"></script>
4. Run 'npm init' so that we can start tracking our node packages with a package.json file.
    + Run: 'npm install --save babel-preset-react@6.24.1 babel-preset-env@1.5.2' which turns our React code        down to ES5 code.
5. Make an 'src'
6. Run 'babel src/app.js --out-file=public/scripts/app.js --presets=env,react' so that our 'app.js' file in our scripts folder is compiled down to ES5 code for us using Babel.
    + You can add '--watch' to the end of the above command to keep a live watch and app.js file regeneration     going.
7. Running 'live-server' is used to keep the web server alive and looking / refreshing any changes made.

Re-rendering JSX on events (user data change).
    - Something like a counter (with buttons and a score display) will need to be re-rendered by ReactDOM.render in order to reflect a change of value.
    - you can initiate a component variable. 
    - Throw the ReactDOM.render() call inside of a function that gets called when:
        1. The web page is first fully loaded
        2. When a user event changes values and the code needs to be rendered to reflect the change.
        + This function will also assign (re-assign) the value(s) of the components that encase the value that changed. Call ReactDOM.render([componentThatChanged], appRoot) at the end.

Automating running babel-cli and live-server
    - Run the following to uninstall: 'npm uninstall -g live-server babel-cli'
        + AVOID Global modules.
    - Add the packages manually with 'npm install babel-cli@6.24.1 live-server'
        + This adds them to package.json
    - THEN define these scripts within the 'scripts' section in package.json (naming them whatever you like)

Adding webpack
    - Run 'npm install --save webpack@3.1.0'
    - You will have to define in the webpack.config.js file where it's entry point is (usually app.js) and where to output (bundle.js)
        + Use the path module built into node to join paths.
        + designate where the bundle.js should populate (in the public folder)
    - add the '--watch' tag to the webpack build script in package.json so that it automatically watches for changes.
        + Remember, at this point you still need live-server (npm run serve) running when you run npm run build.

Exporting and Importing
    - Should now be available
    - export {namedExport1, namedExport2, export3 as default} => for multiple exports
        + In the importing file, 'import export3, {namedExport1, namedExport2} from './pathToFile.js'
        + In the case of defaults, you can name them anything you want on import.
    - for singular exports: export default functionName
        + In the importing file, 'import functionName from './pathToFile.js'

Using Babel to incorporate (convert) JSX to React  
    - run 'npm install babel-core@6.25.0 babel-loader@7.1.1 --save'
    - Then set up the module part of webpack => rules array
    - THEN you need a separate configuration file (.babelrc)
        + This will tell babel what to do using its presets.